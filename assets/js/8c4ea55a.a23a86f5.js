"use strict";(self.webpackChunkwiznet_document=self.webpackChunkwiznet_document||[]).push([[93977],{74162:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"Product/iMCU/W7500/Peripherals-internal/uart","title":"Universal Asynchronous Receive Transmit (UART)","description":"Introduction","source":"@site/docs/Product/iMCU/W7500/Peripherals-internal/uart.md","sourceDirName":"Product/iMCU/W7500/Peripherals-internal","slug":"/Product/iMCU/W7500/Peripherals-internal/uart","permalink":"/Product/iMCU/W7500/Peripherals-internal/uart","draft":false,"unlisted":false,"editUrl":"https://github.com/Wiznet/document_framework/tree/master/docs/Product/iMCU/W7500/Peripherals-internal/uart.md","tags":[],"version":"current","frontMatter":{"id":"uart","title":"Universal Asynchronous Receive Transmit (UART)","date":"2020-04-03T00:00:00.000Z"},"sidebar":"docs","previous":{"title":"TCP/IP core Offload Engine (TOE)","permalink":"/Product/iMCU/W7500/Peripherals-internal/toe"},"next":{"title":"Watchdog Timer (WDT)","permalink":"/Product/iMCU/W7500/Peripherals-internal/wdt"}}');var n=i(74848),a=i(28453);const s={id:"uart",title:"Universal Asynchronous Receive Transmit (UART)",date:new Date("2020-04-03T00:00:00.000Z")},l=void 0,o={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Features",id:"features",level:2},{value:"Functional description",id:"functional-description",level:2},{value:"Baud rate calculation",id:"baud-rate-calculation",level:3},{value:"Data transmission",id:"data-transmission",level:3},{value:"Data receive",id:"data-receive",level:3},{value:"Hardware flow control",id:"hardware-flow-control",level:3},{value:"Peripheral_Examples",id:"peripheral_examples",level:2}];function c(e){const t={a:"a",h2:"h2",h3:"h3",hr:"hr",img:"img",li:"li",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,n.jsx)(t.p,{children:"The UART supports synchronous one-way communication, half-duplex single wire communication, and multiprocessor communications(CTS/RTS)."}),"\n",(0,n.jsx)(t.h2,{id:"features",children:"Features"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Serial-to-parallel conversion on data received from a peripheral device"}),"\n",(0,n.jsx)(t.li,{children:"Parallel-to-serial conversion on data transmitted to the peripheral device"}),"\n",(0,n.jsx)(t.li,{children:"Data size of 5,6,7 and 8 its"}),"\n",(0,n.jsx)(t.li,{children:"One or two stop bits"}),"\n",(0,n.jsx)(t.li,{children:"Even, odd, stick, or no-parity bit generation and detection"}),"\n",(0,n.jsx)(t.li,{children:"Support of hardware flow control"}),"\n",(0,n.jsx)(t.li,{children:"Programmable FIFO disabling for 1-byte depth."}),"\n",(0,n.jsx)(t.li,{children:"Programmable use of UART or IrDA SIR input/output"}),"\n",(0,n.jsx)(t.li,{children:"False start bit detection"}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"functional-description",children:"Functional description"}),"\n",(0,n.jsx)(t.p,{children:"UART bidirectional communication requires a minimum of two pins: RX, TX\nThe frame are comprised of:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"An Idle Line prior to transmission or reception"}),"\n",(0,n.jsx)(t.li,{children:"A start bit"}),"\n",(0,n.jsx)(t.li,{children:"A data word (8 or 9 bits) least significant bit first"}),"\n",(0,n.jsx)(t.li,{children:"1, 1.5, 2 Stop bits indicating that the frame is complete"}),"\n",(0,n.jsx)(t.li,{children:"The USART interface uses a baud rate generator"}),"\n",(0,n.jsx)(t.li,{children:"A status register (UART1_RISR)"}),"\n",(0,n.jsx)(t.li,{children:"data registers (UART1DR)"}),"\n",(0,n.jsx)(t.li,{children:"A baud rate register (UART1_IBRD,UART1_FBRD)"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"The below figure shows UART0,1 Block diagram"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:i(44795).A+"",title:"Figure 1 UART block diagram",width:"1068",height:"800"})}),"\n",(0,n.jsx)(t.p,{children:"The below Figure shows the UART character frame"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:i(83909).A+"",title:"Figure 2 UART character frame",width:"951",height:"258"})}),"\n",(0,n.jsx)(t.h3,{id:"baud-rate-calculation",children:"Baud rate calculation"}),"\n",(0,n.jsx)(t.p,{children:"UARTx can operate with or without using the Fractional Divider. The baud rate divisor is a 22-bit number consisting the UARTxIBRD(16-bit integer) and the UARTxFBRD(6-bit fractional).\nThis is used by the baud rate generator to determine the bit period."}),"\n",(0,n.jsx)("img",{src:"http://latex.codecogs.com/gif.latex?Baud&space;Rate&space;Divisor&space;=",title:"Baud Rate Divisor ="}),"\n",(0,n.jsx)("img",{src:"http://latex.codecogs.com/gif.latex?UARTCLK/((16*baud&space;rate))=&space;\u3016BRD\u3017_I+&space;\u3016BRD\u3017_F",title:"UARTCLK/((16*baud rate))= \u3016BRD\u3017_I+ \u3016BRD\u3017_F"}),"\n",(0,n.jsx)(t.p,{children:"The below Figure shows UART divider flow chart"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:i(52287).A+"",title:"Figure 3 UART divider flow chart",width:"982",height:"634"})}),"\n",(0,n.jsx)(t.p,{children:"The below Figure shows how to set the UART Initial value."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:i(48134).A+"",title:"Figure 4 UART Initial setting flow chart",width:"884",height:"716"})}),"\n",(0,n.jsx)(t.h3,{id:"data-transmission",children:"Data transmission"}),"\n",(0,n.jsx)(t.p,{children:"Data transmitted is stored in a 32-byte FIFOs. Transmit data is written into the transmit FIFO for transmission. If UART is enabled, it causes a data frame to start transmitting with parameters indicated in the UARTxLCR_H.\nData continues to transmit until there is no data left in the transmit FIFO. The BUSY bit of UARTxFR is \u20181\u2019 as soon as data is written to the transmit FIFO, which means the FIFO is not empty, and remains as \u20181\u2019 while data is being transmitted."}),"\n",(0,n.jsx)(t.h3,{id:"data-receive",children:"Data receive"}),"\n",(0,n.jsx)(t.p,{children:"Received data is stored in the 32-byte FIFOs. When a start bit has been received, it begins running and data is sampled on the eighth cycle of that counter in UART mode. A valid stop bit is confirmed if UARTRXD is \u20181\u2019. When a full word is received, the data is stored in the receive FIFO. Error bit is stored in bit[10:8] of UARTxCR and overrun is stored in bit[11] of UARTxCR."}),"\n",(0,n.jsx)(t.p,{children:"The below figure shows Transmit and Receive data flow chart."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:i(5070).A+"",title:"Figure 5 Transmit and Receive data flow chart",width:"936",height:"814"})}),"\n",(0,n.jsx)(t.h3,{id:"hardware-flow-control",children:"Hardware flow control"}),"\n",(0,n.jsx)(t.p,{children:"The below Figure shows Hardware flow control description."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:i(70809).A+"",title:"Figure 6 Hardware flow control description",width:"991",height:"438"})}),"\n",(0,n.jsx)(t.p,{children:"The RTS flow control is enabled by setting the RTSen of UARTxCR. If RTS is enabled, the data flow is controlled as follows.\nWhen the receiver FIFO level reaches the programmed trigger level, nUARTRTS(pin) is asserted(to a low value). nUARTRTS is reasserted(to a low level) once the receiver FIFO has reached the previous trigger level. The reasserted of nUARTRTS signals to the sending UART to continue transmitting data."}),"\n",(0,n.jsx)(t.p,{children:"The CTS flow control is enabled, the transmitter can only transmit data when nUARTCTS is asserted. When nUARTCTR is re-asserted(to a low) the transmitter sends the next byte. To stop the transmitter from sending the following byte, nUARTCTS must be released before the middle of the last stop bit that is currently being sent."}),"\n",(0,n.jsx)(t.p,{children:"The below Figure shows CTS Functinoal Timing."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:i(65061).A+"",title:"Figure 7 CTS Functional Timing",width:"1162",height:"182"})}),"\n",(0,n.jsx)(t.p,{children:"The below Figure shows how software should use the RTS/CTR."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:i(57782).A+"",title:"Figure 8 Algorithm for setting CTS/RTS flowchart",width:"723",height:"867"})}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsx)(t.h2,{id:"peripheral_examples",children:"Peripheral_Examples"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"/Product/iMCU/W7500/Peripherals-internal/inter",children:"UART Interrupt example"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"/Product/iMCU/W7500/Peripherals-internal/printf",children:"UART Printf example"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"/Product/iMCU/W7500/Peripherals-internal/polling",children:"UART Polling example"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"/Product/iMCU/W7500/Peripherals-internal/flowcontrol",children:"UART Hardware FlowControl example"})}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},44795:(e,t,i)=>{i.d(t,{A:()=>r});const r=i.p+"assets/images/uart_block_diagram-50abce4a05d13a3cc80cdb7b8d4eb63d.jpg"},83909:(e,t,i)=>{i.d(t,{A:()=>r});const r=i.p+"assets/images/uart_character_frame-b2966e834e5d57d63ead553d0d2a3f10.jpg"},65061:(e,t,i)=>{i.d(t,{A:()=>r});const r=i.p+"assets/images/uart_cts_timing-674747e7a2cea062abf6f82ea14391e8.jpg"},52287:(e,t,i)=>{i.d(t,{A:()=>r});const r=i.p+"assets/images/uart_divider_flow_chart-83eb98fd4adbbc19a44ea0c68574465d.jpg"},70809:(e,t,i)=>{i.d(t,{A:()=>r});const r=i.p+"assets/images/uart_hw_flow_chart-865681530af58cd0f79c5991533428cb.jpg"},48134:(e,t,i)=>{i.d(t,{A:()=>r});const r=i.p+"assets/images/uart_init_flow_chart-7cadc259955c3d0a658bb1bb637f6f49.jpg"},57782:(e,t,i)=>{i.d(t,{A:()=>r});const r=i.p+"assets/images/uart_set_flow_chart-f0a776d0413dc28ce8b5114e061af167.jpg"},5070:(e,t,i)=>{i.d(t,{A:()=>r});const r=i.p+"assets/images/uart_txrxdata_flow_chart-300a2f9966b85ec056dd9b333a1e36ac.jpg"},28453:(e,t,i)=>{i.d(t,{R:()=>s,x:()=>l});var r=i(96540);const n={},a=r.createContext(n);function s(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);