"use strict";(self.webpackChunkwiznet_document=self.webpackChunkwiznet_document||[]).push([[80018],{32105:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var s=t(85893),i=t(11151);const r={id:"udp",title:"W5500 UDP Function",date:new Date("2020-04-07T00:00:00.000Z")},a=void 0,o={id:"Product/iEthernet/W5500/Application/udp",title:"W5500 UDP Function",description:"By setting some register and memory operation, W5500 provides internet",source:"@site/docs/Product/iEthernet/W5500/Application/UDP.md",sourceDirName:"Product/iEthernet/W5500/Application",slug:"/Product/iEthernet/W5500/Application/udp",permalink:"/Product/iEthernet/W5500/Application/udp",draft:!1,unlisted:!1,editUrl:"https://github.com/Wiznet/document_framework/tree/master/docs/Product/iEthernet/W5500/Application/UDP.md",tags:[],version:"current",frontMatter:{id:"udp",title:"W5500 UDP Function",date:"2020-04-07T00:00:00.000Z"},sidebar:"docs",previous:{title:"W5500 TCP Function",permalink:"/Product/iEthernet/W5500/Application/tcp"},next:{title:"IPRAW",permalink:"/Product/iEthernet/W5500/Application/ipraw"}},c={},d=[{value:"Initialization",id:"initialization",level:2},{value:"Basic Setting",id:"basic-setting",level:3},{value:"Setting network information",id:"setting-network-information",level:3},{value:"Set socket memory information",id:"set-socket-memory-information",level:3},{value:"Data Communications",id:"data-communications",level:2},{value:"UDP",id:"udp",level:3},{value:"Unicast and Broadcast",id:"unicast-and-broadcast",level:3},{value:"Note: Broadcast IP",id:"note-broadcast-ip",level:5},{value:"SOCKET Initialization",id:"socket-initialization",level:5},{value:"Check received data",id:"check-received-data",level:5},{value:"Receiving process",id:"receiving-process",level:5},{value:"Check send data / sending process",id:"check-send-data--sending-process",level:5},{value:"Check complete sending / Timeout",id:"check-complete-sending--timeout",level:5},{value:"Check Finished / SOCKET close",id:"check-finished--socket-close",level:4},{value:"Multicast",id:"multicast",level:3},{value:"SOCKET Initialization",id:"socket-initialization-1",level:5},{value:"Check received data",id:"check-received-data-1",level:5},{value:"Receiving process",id:"receiving-process-1",level:5},{value:"Check send data / Sending Process",id:"check-send-data--sending-process-1",level:5},{value:"Check complete sending / Timeout",id:"check-complete-sending--timeout-1",level:5},{value:"Check finished / SOCKET close",id:"check-finished--socket-close-1",level:5}];function h(e){const n={a:"a",br:"br",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",h5:"h5",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"By setting some register and memory operation, W5500 provides internet\nconnectivity. This chapter describes how it can be operated."}),"\n",(0,s.jsx)(n.h2,{id:"initialization",children:"Initialization"}),"\n",(0,s.jsxs)(n.p,{children:["You ",(0,s.jsx)(n.strong,{children:"must check PHY LINK"}),"\n",(0,s.jsx)(n.em,{children:"(0 bit of PHYCFGR)"})," ",(0,s.jsx)(n.strong,{children:"before attempting to make a network connection"}),"\nusing sockets."]}),"\n",(0,s.jsx)(n.h3,{id:"basic-setting",children:"Basic Setting"}),"\n",(0,s.jsx)(n.p,{children:"For the W5500 operation, select and utilize appropriate registers shown\nbelow."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Mode Register (MR)"}),"\n",(0,s.jsx)(n.li,{children:"Interrupt Mask Register (IMR)"}),"\n",(0,s.jsx)(n.li,{children:"Retry Time-value Register (RTR)"}),"\n",(0,s.jsx)(n.li,{children:"Retry Count Register (RCR)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"For more information of above registers, refer to the \u201cRegister\nDescriptions.\u201d"}),"\n",(0,s.jsx)(n.h3,{id:"setting-network-information",children:"Setting network information"}),"\n",(0,s.jsx)(n.p,{children:"Basic network information setting for communication: It must be set the\nbasic network information."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["SHAR(Source Hardware Address Register)","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"It is prescribed that the source hardware addresses, which is\nset by SHAR, use unique hardware addresses (Ethernet MAC\naddress) in the Ethernet MAC layer. The IEEE manages the MAC\naddress allocation. The manufacturer which produces the network\ndevice allocates the MAC address to product."}),"\n",(0,s.jsx)(n.li,{children:"Details on MAC address allocation refer to the website as below."}),"\n",(0,s.jsxs)(n.li,{children:["\ud83c\udf0e ",(0,s.jsx)(n.a,{href:"http://www.ieee.org/",children:"http://www.ieee.org/"})]}),"\n",(0,s.jsxs)(n.li,{children:["\ud83c\udf0e ",(0,s.jsx)(n.a,{href:"http://standards.ieee.org/regauth/oui/index.shtml",children:"http://standards.ieee.org/regauth/oui/index.shtml"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"GAR(Gateway Address Register)"}),"\n",(0,s.jsx)(n.li,{children:"SUBR(Subnet Mask Register)"}),"\n",(0,s.jsx)(n.li,{children:"SIPR(Source IP Address Register)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"set-socket-memory-information",children:"Set socket memory information"}),"\n",(0,s.jsx)(n.p,{children:"This stage sets the socket tx/rx memory information. The base address\nand mask address of each socket are fixed and saved in this stage."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"In case of, assign 2KB rx, tx memroy per SOCKET"})})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"In case of, assign 2KB rx, tx memory per SOCKET\n{\nSn_RXMEM_SIZE(ch) = (uint8 *) 2; // Assign 2K rx memory per SOCKET\nSn_TXMEM_SIZE(ch) = (uint8 *) 2; // Assign 2K rx memory per SOCKET\n\n/* Same method, set gS1_TX_BASE, gS1_TX_MASK, gS2_TX_BASE, gS2_TX_MASK,\ngS3_TX_BASE, gS3_TX_MASK, gS4_TX_BASE, gS4_TX_MASK, gS5_TX_BASE, gS5_TX_MASK,\ngS6_TX_BASE, gS6_tx_MASK, gS7_TX_BASE, gS7_TX_MASK */\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"data-communications",children:"Data Communications"}),"\n",(0,s.jsx)(n.p,{children:"After the initialization process, W5500 can transmit and receive the\ndata with others by \u2018open\u2019 the SOCKET of TCP, UDP, IPRAW, and MACRAW\nmode. The W5500 supports the independently and simultaneously usable 8\nSOCKETS. In this section, the communication method for each mode will be\nintroduced."}),"\n",(0,s.jsx)(n.h3,{id:"udp",children:"UDP"}),"\n",(0,s.jsx)(n.p,{children:"The UDP is a Connection-less protocol. It communicates without\n\u201cconnection SOCKET.\u201d The TCP protocol guarantees reliable data\ncommunication, but the UDP protocol uses datagram communication which\nhas no guarantees of data communication. Because the UDP does not use\n\u201cconnection SOCKET,\u201d it can communicate with many other devices with\nthe known host IP address and port number. This is a great advantage;\ncommunication with many others by using just one SOCKET, but also it has\nmany problems such as loss of transmitted data, unwanted data received\nfrom others, etc. To avoid these problems and guarantee reliability, the\nhost retransmits damaged data or ignores the unwanted data which is\nreceived from others. The UDP protocol supports unicast, broadcast, and\nmulticast communication. It follows the below communication flow."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"UDP Operation Flow",src:t(981).Z+"",width:"327",height:"323"})}),"\n",(0,s.jsx)(n.h3,{id:"unicast-and-broadcast",children:"Unicast and Broadcast"}),"\n",(0,s.jsxs)(n.p,{children:["The unicast is one method of UDP communication. It transmits data to one\ndestination at one time. On the other hand, the broadcast communication\ntransmits data to all receivable destinations by using \u2018broadcast IP\naddress (255.255.255.255)\u2019. For example, suppose that the user transmits\ndata to destination A, B, and C. The unicast communication transmits\neach destination A, B, and C at each time. At this time, the\nARP",(0,s.jsx)("sub",{children:"TO"})," can also occur when the user gets the destination\nhardware address of destinations A, B and C. User cannot transmit data\nto destinations which have ARP",(0,s.jsx)("sub",{children:"TO"}),". The broadcast communication\ncan simultaneously transmit data to destination A, B and C at one time\nby using \u201c255.255.255.255\u201d or \u201clocal address | (~subnet address)\u201d IP\naddress. At this time, there is no need to get the destination hardware\naddress about destination A, B and C, and also ARP",(0,s.jsx)("sub",{children:"TO"}),"is not\noccurred."]}),"\n",(0,s.jsx)(n.h5,{id:"note-broadcast-ip",children:"Note: Broadcast IP"}),"\n",(0,s.jsxs)(n.p,{children:["=> The Broadcast IP address can be obtained by performing a bit-wise\nlogical OR operation between the bit complement of the subnet mask and\nthe host\u2019s IP address.",(0,s.jsx)(n.br,{}),"\n","ex> If IP:\u201d222.98.173.123\u201d and the subnet mask:\u201c255.255.255.0\u201d,\nbroadcast IP is \u201c222.98.173.255\u201d"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"Decimal"}),(0,s.jsx)(n.th,{children:"Binary"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"HOST IP"}),(0,s.jsx)(n.td,{children:"222.098.173.123"}),(0,s.jsx)(n.td,{children:"11011110.01100010.10101101.01111011"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Bit Complement Subnet mask"}),(0,s.jsx)(n.td,{children:"000.000.000.255"}),(0,s.jsx)(n.td,{children:"00000000.00000000.00000000.11111111"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Bitwise OR"}),(0,s.jsx)(n.td,{children:"-"}),(0,s.jsx)(n.td,{children:"-"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Broadcast IP"}),(0,s.jsx)(n.td,{children:"222.098.173.255"}),(0,s.jsx)(n.td,{children:"11011110.01100010.10101101.11111111"})]})]})]}),"\n",(0,s.jsx)(n.h5,{id:"socket-initialization",children:"SOCKET Initialization"}),"\n",(0,s.jsxs)(n.p,{children:["For the UDP data communication, SOCKET initialization is required; it\nopens the SOCKET. The SOCKET open process is as followed. At first,\nchoose one SOCKET among the 8 SOCKETS of W5500, then set the protocol\nmode (Sn_MR(P3",":P0",")) of the chosen SOCKET and set the source port number\nSn_PORT0 for communication. Finally, execute the OPEN command. After\nthe OPEN command, the state of Sn_SR is changed to SOCK_UDP. Then the\nSOCKET initialization is complete."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"{\nSTART:\nSn_MR = 0x02; /* sets UDP mode */\nSn_PORT0 = source_port; /* sets source port number */\nSn_CR = OPEN; /* sets OPEN command */\n/* wait until Sn_SR is changed to SOCK_UDP */\nif (Sn_SR != SOCK_UDP) Sn_CR = CLOSE; goto START;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["After W5500 ",(0,s.jsx)(n.strong,{children:"accepts the\ncommand, the Sn_CR register is automatically cleared to 0x00"}),". Even\nthough Sn_CR is cleared to 0x00, the command is still being processed.\n",(0,s.jsx)(n.em,{children:"To check whether the command is completed or not, please check the\nSn_IR or Sn_SR."})]}),"\n",(0,s.jsx)(n.h5,{id:"check-received-data",children:"Check received data"}),"\n",(0,s.jsxs)(n.p,{children:["Check the reception of UDP data from destination. User can also check\nfor received data via TCP communication. It is strongly recommended to\nuse the second method because of the same reasoning from TCP. Please\nrefer to the \u201cTCP SERVER\u201d section. ",(0,s.jsx)(n.a,{href:"tcp#tcp-server",children:"TCP\nSERVER"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"First method :\n{\nif (Sn_IR(RECV) == \u20181\u2019) Sn_IR(RECV) = \u20181\u2019; goto Receiving Process stage;\n/* In this case, if the interrupt of Socket n is activated, interrupt occurs. Refer to IR, IMR\nSn_IMR and Sn_IR. */\n}\nSecond Method :\n{\nif (Sn_RX_RSR0 != 0x0000) goto Receiving Process stage;\n}\n"})}),"\n",(0,s.jsx)(n.h5,{id:"receiving-process",children:"Receiving process"}),"\n",(0,s.jsxs)(n.p,{children:["Process the received UDP data in Internal RX memory.",(0,s.jsx)(n.br,{}),"\n","The structure of received UDP data is as below."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"The Received UDP data format",src:t(63766).Z+"",width:"752",height:"97"})}),"\n",(0,s.jsx)(n.p,{children:"The received UDP data consists of 8bytes PACKET-INFO, and DATA packet.\nThe PACKETINFO contains transmitter\u2019s information (IP address, Port\nnumber) and the length of DATA packet. The UDP can receive UDP data from\nmany others. User can classify the transmitter by transmitter\u2019s\ninformation of PACKET-INFO. It also receives broadcast SOCKET by using\n\u201c255.255.255.255\u201d IP address. So the host should ignore unwanted\nreception by analysis of transmitter\u2019s information. If the DATA size of\nSocket n is larger than Internal RX memory free size, user cannot\nreceive that DATA and also cannot receive fragmented DATA."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"{\n/* Get offset address */\nsrc_ptr = Sn_RX_RD;\n/* select RX memory, refer to Datasheet 14 page */\ncntl_byte = Socket_n_RX_Buffer \n/* read head information (8 bytes) */\nheader_size = 8;\n/* copy header_size bytes of get_start_address to header_address */\nfor(i=0; i<header_size; i++)\n{\n  header[i] = W5500_READ(src_ptr, header);\n}\n/* update src_ptr */\nsrc_ptr += header_size;\n\n/* save remote peer information & received data size */\npeer_ip = header[0 to 3];\npeer_port = header[4 to 5];\nget_size = header[6 to 7];\n\n/* copy len bytes of src_ptr to destination_address */\nfor(i=0; i<get_size; i++)\n{\n  *(dst_ptr+i) = W5500_READ(addr, cntl_byte, src_ptr+1);\n}\n/* increase Sn_RX_RD as length of len+ header_size */\nSn_RX_RD += get_size;\n/* set RECV command */\nSn_CR = RECV;\n}\n"})}),"\n",(0,s.jsx)(n.h5,{id:"check-send-data--sending-process",children:"Check send data / sending process"}),"\n",(0,s.jsx)(n.p,{children:"The size of DATA that the user wants to transmit cannot be larger than\nInternal TX memory. If it is larger than MTU, it is automatically\ndivided by MTU unit and transmitted. The Sn_DIPR0 is set\n\u201c255.255.255.255\u201d when user wants to broadcast."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"{\n/* first, get the free TX memory size */\nFREESIZE:\nfreesize = Sn_TX_FSR0;\nif (freesize<len) goto FREESIZE; // len is send size\n\n/* Write the value of remote_ip, remote_port to the Socket n Destination IP Address\nRegister(Sn_DIPR), Socket n Destination Port Register(Sn_DPORT). */\nSn_DIPR0 = remote_ip;\nSn_DPORT0 = remote_port;\n\n/* Get offset address */\ndst_ptr = Sn_TX_WR;\n/* select TX memory, refer to Datasheet 14 page */\ncntl_byte = Socket_n_TX_Buffer \n/* copy len bytes of source_address to dst_ptr */\nfor(i=0; i<len; i++)\n{\n  W5500_WRITE(addr, cntl_byte, dst_ptr+i);\n}\n/* increase Sn_TX_WR0 as length of len */\nSn_TX_WR += len;\n/* set SEND command */\nSn_CR = SEND;\n}\n"})}),"\n",(0,s.jsx)(n.h5,{id:"check-complete-sending--timeout",children:"Check complete sending / Timeout"}),"\n",(0,s.jsxs)(n.p,{children:["To transmit the next data, user must check that the prior SEND command\nis completed. The larger the data size, the more time to complete the\nSEND command. Therefore, the user must properly divide the data to\ntransmit. The ARP",(0,s.jsx)("sub",{children:"TO"})," can occur when user transmits UDP data.\nIf ARP",(0,s.jsx)("sub",{children:"TO"})," occurs, the UDP data transmission has failed."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"First method :\n{\n/* check SEND command completion */\nwhile(Sn_IR(SENDOK)==\u20180\u2019) /* wait interrupt of SEND completion */\n{\n/* check ARPTO */\nif (Sn_IR(TIMEOUT)==\u20181\u2019) Sn_IR(TIMEOUT)=\u20181\u2019; goto Next stage;\n}\nSn_IR(SENDOK) = \u20181\u2019; /* clear previous interrupt of SEND completion */\n}\nSecond method :\n{\nIf (Sn_CR == 0x00) transmission is completed.\nIf (Sn_IR(TIMEOUT bit) == \u20181\u2019) goto next stage;\n/* In this case, if the interrupt of Socket n is activated, interrupt occurs. Refer to\nInterrupt Register(IR), Interrupt Mask Register (IMR) and Socket n Interrupt Register (Sn_IR).\n*/\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"check-finished--socket-close",children:"Check Finished / SOCKET close"}),"\n",(0,s.jsx)(n.p,{children:"If user doesn\u2019t need the communication any more, close the Socket n."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"{\n/* clear remained interrupts */\nSn_IR = 0x00FF;\nIR(n) = \u20181\u2019;\n/* set CLOSE command */\nSn_CR = CLOSE;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"multicast",children:"Multicast"}),"\n",(0,s.jsxs)(n.p,{children:["The broadcast communication communicates with many and unspecified\nothers. But the multicast communication communicates with many specified\nothers who registered at a multicast-group. Suppose that A, B, and C are\nregistered at a specified multicast-group. If user transmits data to\nmulticast-group (contains A), B and C also receive the DATA for A. To\nuse multicast communication, the destination list registers to\nmulticast-group by using IGMP protocol. The multicast-group consists of\n\u2018Group hardware address,\u2019 \u2018Group IP address,\u2019 and \u2018Group port number.\u2019\nUser cannot change the \u2018Group hardware address\u2019 and \u2018Group IP address.\u2019\nBut the \u2018Group port number\u2019 can be changed.",(0,s.jsx)(n.br,{}),"\n","The \u2018Group hardware address\u2019 is selected at the assigned range (From\n\u201c01:00:5e:00:00:00\u201dto \u201c01:00:5e:7f:ff",":ff","\u201d) and the \u2018Group IP address\u2019\nis selected in D-class IP address (From \u201c224.0.0.0\u201d to\n\u201c239.255.255.255\u201d, please refer to the website;\n",(0,s.jsx)(n.a,{href:"http://www.iana.org/assignments/multicast-addresses",children:"http://www.iana.org/assignments/multicast-addresses"}),").",(0,s.jsx)(n.br,{}),"\n","When selecting, the upper 23bit of 6bytes \u2018Group hardware address\u2019 and\nthe 4bytes \u2018Group IP address\u2019 must be the same. For example, if the user\nselects the \u2018Group IP address\u2019 to \u201c244.1.1.11,\u201d the \u2018Group hardware\naddress\u2019 is selected to \u201c01:00:5e:01:01:0b.\u201d Please refer to the\n\u201cRFC1112\u201d (",(0,s.jsx)(n.a,{href:"http://www.ietf.org/rfc.html",children:"http://www.ietf.org/rfc.html"}),").",(0,s.jsx)(n.br,{}),"\n","In the W5500, IGMP processing to register the multicast-group is\ninternally (automatically) processed. When the user opens the Socket n\nwith multicast mode, the \u201cJoin\u201d message is internally transmitted. If\nthe user closes it, the \u201cLeave\u201d message is internally transmitted. After\nthe SOCKET opens, the \u201cReport\u201d message is periodically and internally\ntransmitted when the user communicates.",(0,s.jsx)(n.br,{}),"\n","The W5500 support IGMP version 1 and version 2 only. If user wants use\nan updated version, the host processes IGMP directly by using the IPRAW\nmode SOCKET."]}),"\n",(0,s.jsx)(n.h5,{id:"socket-initialization-1",children:"SOCKET Initialization"}),"\n",(0,s.jsxs)(n.p,{children:["Choose one SOCKET for multicast communication among 8 SOCKETS of W5500.\nSet the Sn_DHAR0 to \u2018Multicast-group hardware address\u2019 and set the\nSn_DIPR0 to \u2018Multicastgroup IP address.\u2019 Then set the Sn_PORT0 and\nSn_DPORT0 to \u2018Multicast-group port number.\u2019 Set the Sn_MR(P3",":P0",") to\nUDP and set the Sn_MR(MULTI) to \u20181.\u2019 Finally, execute OPEN command. If\nthe state of Sn_SR is changed to SOCK_UDP after the OPEN command, the\nSOCKET initialization is completed."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"{\nSTART:\n/* set Multicast-Group information */\nSn_DHAR0 = 0x01; /* set Multicast-Group H/W address(01:00:5e:01:01:0b) */\nSn_DHAR1 = 0x00;\nSn_DHAR2 = 0x5E;\nSn_DHAR3 = 0x01;\nSn_DHAR4 = 0x01;\nSn_DHAR5 = 0x0B;\nSn_DIPR0 = 211; /* set Multicast-Group IP address(211.1.1.11) */\nSn_DIPR1 = 1;\nSn_DIPR2 = 1;\nSn_DIRP3 = 11;\nSn_DPORT0 = 0x0BB8; /* set Multicast-GroupPort number(3000) */\nSn_PORT0 = 0x0BB8; /* set SourcePort number(3000) */\nSn_MR = 0x02 | 0x80; /* set UDP mode & Multicast on Socket n Mode Register */\nSn_CR = OPEN; /* set OPEN command */\n/* wait until Sn_SR is changed to SOCK_UDP */\nif (Sn_SR != SOCK_UDP) Sn_CR = CLOSE; goto START;\n}\n"})}),"\n",(0,s.jsx)(n.h5,{id:"check-received-data-1",children:"Check received data"}),"\n",(0,s.jsx)(n.p,{children:"Refer to the \u201cUnicast & Broadcast.\u201d section."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"#unicast-and-broadcast",children:"Unicast & Broadcast"})}),"\n",(0,s.jsx)(n.h5,{id:"receiving-process-1",children:"Receiving process"}),"\n",(0,s.jsxs)(n.p,{children:["Refer to the \u201cUnicast & Broadcast.\u201d section. ",(0,s.jsx)(n.a,{href:"#unicast-and-broadcast",children:"Unicast &\nBroadcast"})]}),"\n",(0,s.jsx)(n.h5,{id:"check-send-data--sending-process-1",children:"Check send data / Sending Process"}),"\n",(0,s.jsx)(n.p,{children:"Since the user sets the information about multicast-group at SOCKET\ninitialization, user does not need to set IP address and port number for\ndestination any more. Therefore, copy the transmission data to internal\nTX memory and executes SEND command."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"{\n/* first, get the free TX memory size */\nFREESIZE:\nfreesize = Sn_TX_FSR;\nif (freesize<len) goto FREESIZE; // len is send size\n/* calculate offset address */\ndst_mask = Sn_TX_WR0 &gSn_TX_MASK; // dst_mask is offset address\n/* calculate start address(physical address) */\ndst_ptr = gSn_TX_BASE + dst_mask; // dst_ptr is physical start address\n/* if overflow SOCKETTX memory */\nif ( (dst_mask + len) > (gSn_TX_MASK + 1) )\n{\n/* copy upper_size bytes of source_addr to destination_address */\nupper_size = (gSn_TX_MASK + 1) \u2013 dst_mask;\nmemcpy((0x0000 + source_addr), (0x0000 + dst_ptr), upper_size);\n/* update source_addr*/\nsource_addr += upper_size;\n/* copy left_size bytes of source_addr to gSn_TX_BASE */\nleft_size = len \u2013 upper_size;\nmemcpy( source_addr, gSn_TX_BASE, left_size);\n}\nelse\n{\n/* copy len bytes of source_addr to dst_ptr */\nmemcpy( source_addr, dst_ptr, len);\n}\n/* increase Sn_TX_WR as length of len */\nSn_TX_WR0 += send_size;\n/* set SEND command */\nSn_CR = SEND;\n}\n"})}),"\n",(0,s.jsx)(n.h5,{id:"check-complete-sending--timeout-1",children:"Check complete sending / Timeout"}),"\n",(0,s.jsx)(n.p,{children:"Since the host manages all protocol process for data communication,\ntimeout cannot occur."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"{\n/* check SEND command completion */\nwhile(S0_IR(SENDOK)==\u20180\u2019); /* wait interrupt of SEND completion */\nS0_IR(SENDOK) = \u20181\u2019; /* clear previous interrupt of SEND completion */\n}\n"})}),"\n",(0,s.jsx)(n.h5,{id:"check-finished--socket-close-1",children:"Check finished / SOCKET close"}),"\n",(0,s.jsxs)(n.p,{children:["Refer to the \u201cUnicast & Broadcast.\u201d section. ",(0,s.jsx)(n.a,{href:"#unicast-and-broadcast",children:"Unicast & Broadcast"})]})]})}function l(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},63766:(e,n,t)=>{t.d(n,{Z:()=>s});const s=t.p+"assets/images/received_udp_data-e0e149ec8f5c7d5adf6bcf1321b812c0.jpg"},981:(e,n,t)=>{t.d(n,{Z:()=>s});const s=t.p+"assets/images/udp_flow-ef79aaa7b60e7be7c674fd177a99cfdd.jpg"},11151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>a});var s=t(67294);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);