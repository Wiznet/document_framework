"use strict";(self.webpackChunkwiznet_document=self.webpackChunkwiznet_document||[]).push([[3662],{67058:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>l,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var s=t(85893),i=t(11151);const o={id:"tcp",title:"W5500 TCP Function",date:new Date("2020-04-07T00:00:00.000Z")},c=void 0,r={id:"Product/iEthernet/W5500/Application/tcp",title:"W5500 TCP Function",description:"By setting some register and memory operation, W5500 provides internet",source:"@site/docs/Product/iEthernet/W5500/Application/TCP.md",sourceDirName:"Product/iEthernet/W5500/Application",slug:"/Product/iEthernet/W5500/Application/tcp",permalink:"/Product/iEthernet/W5500/Application/tcp",draft:!1,unlisted:!1,editUrl:"https://github.com/Wiznet/document_framework/tree/master/docs/Product/iEthernet/W5500/Application/TCP.md",tags:[],version:"current",frontMatter:{id:"tcp",title:"W5500 TCP Function",date:"2020-04-07T00:00:00.000Z"},sidebar:"docs",previous:{title:"W5500 Application",permalink:"/Product/iEthernet/W5500/Application/"},next:{title:"W5500 UDP Function",permalink:"/Product/iEthernet/W5500/Application/udp"}},a={},d=[{value:"Initialization",id:"initialization",level:2},{value:"Basic Setting",id:"basic-setting",level:3},{value:"Setting network information",id:"setting-network-information",level:2},{value:"Set socket memory information",id:"set-socket-memory-information",level:2},{value:"Data Communications",id:"data-communications",level:2},{value:"TCP",id:"tcp",level:2},{value:"TCP SERVER",id:"tcp-server",level:2},{value:"SOCKET Initialization",id:"socket-initialization",level:3},{value:"LISTEN",id:"listen",level:3},{value:"ESTABLISHMENT",id:"establishment",level:3},{value:"ESTABLISHMENT : Check received data",id:"establishment--check-received-data",level:3},{value:"ESTABLISHMENT : Receiving process",id:"establishment--receiving-process",level:3},{value:"ESTABLISHMENT: Check send data / Send process",id:"establishment-check-send-data--send-process",level:3},{value:"ESTABLISHMENT : Check disconnect-request(FIN packet)",id:"establishment--check-disconnect-requestfin-packet",level:3},{value:"ESTABLISHMENT : Check disconnect / disconnecting process",id:"establishment--check-disconnect--disconnecting-process",level:3},{value:"ESTABLISHMENT : Check closed",id:"establishment--check-closed",level:3},{value:"ESTABLISHMENT: Timeout",id:"establishment-timeout",level:3},{value:"SOCKET Close",id:"socket-close",level:3},{value:"TCP CLIENT",id:"tcp-client",level:2},{value:"CONNECT",id:"connect",level:3}];function h(e){const n={a:"a",br:"br",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"By setting some register and memory operation, W5500 provides internet\nconnectivity. This chapter describes how it can be operated."}),"\n",(0,s.jsx)(n.h2,{id:"initialization",children:"Initialization"}),"\n",(0,s.jsxs)(n.p,{children:["You ",(0,s.jsx)(n.strong,{children:"must check PHY LINK"}),"\n",(0,s.jsx)(n.em,{children:"(0 bit of PHYCFGR)"})," ",(0,s.jsx)(n.strong,{children:"before attempting to make a network connection"}),"\nusing sockets."]}),"\n",(0,s.jsx)(n.h3,{id:"basic-setting",children:"Basic Setting"}),"\n",(0,s.jsx)(n.p,{children:"For the W5500 operation, select and utilize appropriate registers shown\nbelow."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Mode Register (MR)"}),"\n",(0,s.jsx)(n.li,{children:"Interrupt Mask Register (IMR)"}),"\n",(0,s.jsx)(n.li,{children:"Retry Time-value Register (RTR)"}),"\n",(0,s.jsx)(n.li,{children:"Retry Count Register (RCR)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"For more information of above registers, refer to the \u201cRegister\nDescriptions.\u201d"}),"\n",(0,s.jsx)(n.h2,{id:"setting-network-information",children:"Setting network information"}),"\n",(0,s.jsx)(n.p,{children:"Basic network information setting for communication: It must be set the\nbasic network information."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["SHAR(Source Hardware Address Register)","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"It is prescribed that the source hardware addresses, which is\nset by SHAR, use unique hardware addresses (Ethernet MAC\naddress) in the Ethernet MAC layer. The IEEE manages the MAC\naddress allocation. The manufacturer which produces the network\ndevice allocates the MAC address to product."}),"\n",(0,s.jsx)(n.li,{children:"Details on MAC address allocation refer to the website as below."}),"\n",(0,s.jsxs)(n.li,{children:["\ud83c\udf0e",(0,s.jsx)(n.a,{href:"http://www.ieee.org/",children:"http://www.ieee.org/"})]}),"\n",(0,s.jsxs)(n.li,{children:["\ud83c\udf0e",(0,s.jsx)(n.a,{href:"http://standards.ieee.org/regauth/oui/index.shtml",children:"http://standards.ieee.org/regauth/oui/index.shtml"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"GAR(Gateway Address Register)"}),"\n",(0,s.jsx)(n.li,{children:"SUBR(Subnet Mask Register)"}),"\n",(0,s.jsx)(n.li,{children:"SIPR(Source IP Address Register)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"set-socket-memory-information",children:"Set socket memory information"}),"\n",(0,s.jsx)(n.p,{children:"This stage sets the socket tx/rx memory information. The base address\nand mask address of each socket are fixed and saved in this stage."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"In case of, assign 2KB rx, tx memroy per SOCKET"})})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"In case of, assign 2KB rx, tx memory per SOCKET\n{\nSn_RXMEM_SIZE(ch) = (uint8 *) 2; // Assign 2K rx memory per SOCKET\nSn_TXMEM_SIZE(ch) = (uint8 *) 2; // Assign 2K rx memory per SOCKET\n\n/* Same method, set gS1_TX_BASE, gS1_TX_MASK, gS2_TX_BASE, gS2_TX_MASK,\ngS3_TX_BASE, gS3_TX_MASK, gS4_TX_BASE, gS4_TX_MASK, gS5_TX_BASE, gS5_TX_MASK,\ngS6_TX_BASE, gS6_tx_MASK, gS7_TX_BASE, gS7_TX_MASK */\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"data-communications",children:"Data Communications"}),"\n",(0,s.jsx)(n.p,{children:"After the initialization process, W5500 can transmit and receive the\ndata with others by \u2018open\u2019 the SOCKET of TCP, UDP, IPRAW, and MACRAW\nmode. The W5500 supports the independently and simultaneously usable 8\nSOCKETS. In this section, the communication method for each mode will be\nintroduced."}),"\n",(0,s.jsx)(n.h2,{id:"tcp",children:"TCP"}),"\n",(0,s.jsx)(n.p,{children:"The TCP is a connection-oriented protocol. The TCP make the connection\nSOCKET by using its own IP address, port number and destination IP\naddress, port number. Then transmits and receives the data by using this\nSOCKET. Methods of making the connection to SOCKET are \u201cTCP SERVER\u201d and\n\u201cTCP CLIENT\u201d. It is divided by transmitting the connect-request (SYN\npacket). The \u201cTCP SERVER\u201d listens to the connect-request from the \u201cTCP\nCLIENT\u201d, and makes connection SOCKET by accepting the transmitted\nconnect-request (Passive-open). The \u201cTCP CLIENT\u201d transmits the\nconnect-request first to \u201cTCP SERVER\u201d to make the connection\n(Active-open)."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"TCP SERVER and TCP CLIENT",src:t(8646).Z+"",width:"869",height:"586"})}),"\n",(0,s.jsx)(n.h2,{id:"tcp-server",children:"TCP SERVER"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"TCP SERVER Operation Flow",src:t(65326).Z+"",width:"614",height:"564"})}),"\n",(0,s.jsx)(n.h3,{id:"socket-initialization",children:"SOCKET Initialization"}),"\n",(0,s.jsx)(n.p,{children:"SOCKET initialization is required for TCP data communication. The\ninitialization is opening the SOCKET. The SOCKET opening process selects\none SOCKET from 8 SOCKETS of the W5500, and sets the protocol mode\n(Sn_MR) and Sn_PORT0 which is source port number (Listen port number\nin \u201cTCP SERVER\u201d) in the selected SOCKET, and then executes OPEN command.\nAfter the OPEN command, if the status of Sn_SR is changed to\nSOCK_INIT, the SOCKET initialization process is completed. The SOCKET\ninitialization process is identically applied in \u201cTCP SERVER\u201d and \u201cTCP\nCLIENT.\u201dThe Initialization process of Socket n in TCP mode is shown\nbelow."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"{\nSTART:\nSn_MR = 0x01; // sets TCP mode\nSn_PORT0 = source_port; // sets source port number\nSn_CR = OPEN; // sets OPEN command\n/* wait until Sn_SR is changed to SOCK_INIT */\nif (Sn_SR != SOCK_INIT) Sn_CR = CLOSE; goto START;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["After W5500 ",(0,s.jsx)(n.strong,{children:"accepts the\ncommand, the Sn_CR register is automatically cleared to 0x00"}),". Even\nthough Sn_CR is cleared to 0x00, the command is still being processed.\n",(0,s.jsx)(n.em,{children:"To check whether the command is completed or not, please check the\nSn_IR or Sn_SR."})]}),"\n",(0,s.jsx)(n.h3,{id:"listen",children:"LISTEN"}),"\n",(0,s.jsx)(n.p,{children:"Run as \u201cTCP SERVER\u201d by LISTEN command."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"{\n/* listen SOCKET */\nSn_CR = LISTEN;\n/* wait until Sn_SR is changed to SOCK_LISTEN */\nif (Sn_SR != SOCK_LISTEN) Sn_CR = CLOSE; goto START;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"establishment",children:"ESTABLISHMENT"}),"\n",(0,s.jsx)(n.p,{children:"When the status of Sn_SR is SOCK_LISTEN, if it receives a SYN packet,\nthe status of Sn_SR is changed to SOCK_SYNRECV and transmits the\nSYN/ACK packet. After that, the Socket n makes a connection. After it\nmakes the connection of Socket n , it enables the data communication.\nThere are two methods to confirm the connection of Socket n ."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"First method :\n{\nif (Sn_IR(CON) == \u20181\u2019)\n/* When an interrupt occurs and the mask bit of Sn_IMR is \u20181\u2019, the interrupt bit of Sn_IR\nbecomes \u20181\u2019 */\nSn_IR(CON) = \u20181\u2019;\n/*In order to clear the Sn_IR bit, the host should write the bit as \u20181\u2019. When all the bits of\nSn_IR is cleared (\u20180\u2019), IR(n) is automatically cleared.*/\ngoto ESTABLISHED stage;\n/* In this case, if the interrupt of Socket n is activated, interrupt occurs. Refer to IR, IMR\nSn_IMR and Sn_IR. */\n}\nSecond method :\n{\nif (Sn_SR == SOCK_ESTABLISHED) goto ESTABLISHED stage;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"establishment--check-received-data",children:"ESTABLISHMENT : Check received data"}),"\n",(0,s.jsx)(n.p,{children:"Confirm the reception of the TCP data."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"First method :\n{\nif (Sn_IR(RECV) == \u20181\u2019) Sn_IR(RECV) = \u20181\u2019; goto Receiving Process stage;\n/* In this case, if the interrupt of Socket n is activated, interrupt occurs. Refer to IR, IMR\nSn_IMR and Sn_IR. */\n}\nSecond Method :\n{\nif (Sn_RX_RSR0 != 0x0000) goto Receiving Process stage;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The First method: set the Sn_IR(RECV) to \u20181\u2019 whenever you receive a\nDATA packet. If the host receives the next DATA packet without setting\nthe Sn_IR(RECV) as \u20181\u2019 in the prior DATA packet, it cannot recognize\nthe Sn_IR(RECV) of the next DATA packet. This is due to the prior\nSn_IR(RECV) and next Sn_IR(RECV) being overlapped. So this method is\nnot recommended if the host cannot perfectly process the DATA packets of\neach Sn_IR(RECV)."}),"\n",(0,s.jsx)(n.h3,{id:"establishment--receiving-process",children:"ESTABLISHMENT : Receiving process"}),"\n",(0,s.jsx)(n.p,{children:"In this process, it processes the TCP data which was received in the\nInternal RX memory. At the TCP mode, the W5500 cannot receive the data\nif the size of received data is larger than the RX memory free size of\nSocket n . If the prior stated condition is happened, the W5500 holds on\nto the connection (pauses), and waits until the RX memory\u2019s free size is\nlarger than the size of the received data."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"{\n/* first, get the received size */\nlen = Sn_RX_RSR; // len is received size\n/* select RX memory, refer to Datasheet 14 page */\ncntl_byte = Socket_n_RX_Buffer \n/* Get offset address */\nsrc_ptr = Sn_RX_RD;\n/* set memory copy len bytes of source_ptr to destination_address */\nfor (i=0; i<len; i++)\n{\n   *(dst_ptr+i) = W5500_READ(addr, cntl_byte, src_ptr+i);\n}\n/* increase Sn_RX_RD as length of len */\nSn_RX_RD += len;\n/* set RECV command */\nSn_CR = RECV;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"establishment-check-send-data--send-process",children:"ESTABLISHMENT: Check send data / Send process"}),"\n",(0,s.jsxs)(n.p,{children:["The size of the transmit data cannot be larger than assigned internal TX\nmemory of Socket n. If the size of transmit data is larger than\nconfigured MSS, it is divided by size of MSS and transmits. To transmit\nthe next data, user must check the completion of prior SEND command. An\nerror may occur if the SEND command executes before completion of prior\nSEND command. The larger the data size, the more time to complete the\nSEND command. So the user should properly divide the data to transmit.",(0,s.jsx)(n.br,{}),"\n","To check the completion of the SEND command, it should be check that the\nsend data length is equal with the actual sent data length. The actual\nsent data length is calculated by the difference of the Sn_TX_RD\nbefore and after performing the SEND command. If the actual sent data is\nless than the send data length, the SEND command is retried for sending\nthe left data. The send process is therefore completed the SENDwhen the\nsum of the actual sent data is equal the send data length. A simple\nexample of the send process is as below",(0,s.jsx)(n.br,{}),"\n","Ex) Send Data Length Size= 10,",(0,s.jsx)(n.br,{}),"\n","- ",(0,s.jsx)(n.strong,{children:"Execute SEND Command with send data length"})]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Calculate the actual sent data length"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If the actual sent data length is 7 (=\nSn_TX_RD_after_SEND-Sn_TX_RD_befor_SEND),"}),"\n",(0,s.jsx)(n.li,{children:"the left Data length= 3"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Retry SEND Command until the sum of the actual sent data length is\nsame the send data length."}),(0,s.jsx)(n.br,{}),"\n","Note: Don\u2019t copy data until the sum of the actual sent data length\nis the send data length."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"{\n/* first, get the free TX memory size */\nFREESIZE:\nfreesize = Sn_TX_FSR;\nif (freesize<len) goto FREESIZE; // len is send size\n\n/* select TX memory, refer to Datasheet 14 page */\ncntl_byte = Socket_n_TX_Buffer \n/* Get offset address */\ndst_ptr = Sn_TX_RD;\n/* set memory copy len bytes of source_ptr to destination_address */\nfor (i=0; i<len; i++)\n{\n   W5500_WRITE(addr, cntl_byte, dst_ptr+i);\n}\n\n/* increase Sn_TX_WR as length of len */\nSn_TX_WR += send_size;\n/* set SEND command */\nSn_CR = SEND;\n/* return real packet size */\nreturn len;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"establishment--check-disconnect-requestfin-packet",children:"ESTABLISHMENT : Check disconnect-request(FIN packet)"}),"\n",(0,s.jsx)(n.p,{children:"Check if the Disconnect-request(FIN packet) has been received. User can\nconfirm the reception of FIN packet as below."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"First method :\n{\nif (Sn_IR(DISCON) == \u20181\u2019) Sn_IR(DISCON)=\u20181\u2019; goto CLOSED stage;\n/* In this case, if the interrupt of Socket n is activated, interrupt occurs. Refer to IR, IMR\nSn_IMR and Sn_IR. */\n}\nSecond method :\n{\nif (Sn_SR == SOCK_CLOSE_WAIT) goto CLOSED stage;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"establishment--check-disconnect--disconnecting-process",children:"ESTABLISHMENT : Check disconnect / disconnecting process"}),"\n",(0,s.jsx)(n.p,{children:"When the user does not need data communication with others, or receives\na FIN packet, disconnect the connection SOCKET."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"{\n/* set DISCON command */\nSn_CR = DISCON;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"establishment--check-closed",children:"ESTABLISHMENT : Check closed"}),"\n",(0,s.jsx)(n.p,{children:"Confirm that the Socket n is disconnected or closed by DISCON or close\ncommand."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"First method :\n{\nif (Sn_IR(DISCON) == \u20181\u2019) goto CLOSED stage;\n/* In this case, if the interrupt of Socket n is activated, interrupt occurs. Refer to IR, IMR\nSn_IMR and Sn_IR. */\n}\nSecond method :\n{\nif (Sn_SR == SOCK_CLOSED) goto CLOSED stage;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"establishment-timeout",children:"ESTABLISHMENT: Timeout"}),"\n",(0,s.jsxs)(n.p,{children:["The timeout can occur by Connect-request(SYN packet) or its\nresponse(SYN/ACK packet), the DATA packet or its response(DATA/ACK\npacket), the Disconnect request FIN packet) or its response(FIN/ACK\npacket) and transmission all TCP packet. If it cannot transmit the above\npackets within \u2018timeout\u2019 which is configured at RTR and RCR, the TCP\nfinal timeout(TCP",(0,s.jsx)("sub",{children:"TO"}),") occurs and the state of Sn_SR is set to\nSOCK_CLOSED. Confirming method of the TCP",(0,s.jsx)("sub",{children:"TO"})," is as below:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"First method :\n{\nif (Sn_IR(TIMEOUT bit) == \u20181\u2019) Sn_IR(TIMEOUT)=\u20181\u2019; goto CLOSED stage;\n/* In this case, if the interrupt of Socket n is activated, interrupt occurs. Refer to IR, IMR\nSn_IMR and Sn_IR. */\n}\nSecond method :\n{\nif (Sn_SR == SOCK_CLOSED) goto CLOSED stage;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"socket-close",children:"SOCKET Close"}),"\n",(0,s.jsxs)(n.p,{children:["It can be used to close the Socket n , which disconnected by\ndisconnect-process, or closed by TCP",(0,s.jsx)("sub",{children:"TO"})," or closed by host\u2019s\nneed without disconnect-process."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"{\n/* clear the remained interrupts of Socket n */\nSn_IR = 0xFF;\nIR(n) = \u20181\u2019;\n/* set CLOSE command */\nSn_CR = CLOSE;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"tcp-client",children:"TCP CLIENT"}),"\n",(0,s.jsx)(n.p,{children:'It is same as TCP server except \u2018CONNECT\u2019 state. User can refer to the\nabove "TCP SERVER\u201d section.'}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"TCP CLIENT Operation Flow",src:t(23071).Z+"",width:"624",height:"529"})}),"\n",(0,s.jsx)(n.h3,{id:"connect",children:"CONNECT"}),"\n",(0,s.jsxs)(n.p,{children:["Transmit the connect-request (SYN packet) to \u201cTCP SERVER\u201d. It may occurs\nthe timeout such as ARP",(0,s.jsx)("sub",{children:"TO"}),", TCP",(0,s.jsx)("sub",{children:"TO"})," when make the\n\u201cconnection SOCKET\u201d with \u201cTCP SERVER\u201d"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"{\nSn_DIPR0 = server_ip; /* set TCP SERVER IP address*/\nSn_DPORT0 = server_port; /* set TCP SERVER listen port number*/\nSn_CR = CONNECT; /* set CONNECT command */\n}\n"})})]})}function l(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},23071:(e,n,t)=>{t.d(n,{Z:()=>s});const s=t.p+"assets/images/client_flow-04da672c829305cf8744e516eea840c0.jpg"},65326:(e,n,t)=>{t.d(n,{Z:()=>s});const s=t.p+"assets/images/server_flow-6cf61961e097a0578af9ed20276e28bd.jpg"},8646:(e,n,t)=>{t.d(n,{Z:()=>s});const s=t.p+"assets/images/serverclient-908557ee7b67f55d5fb06eb580113be1.jpg"},11151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>c});var s=t(67294);const i={},o=s.createContext(i);function c(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);